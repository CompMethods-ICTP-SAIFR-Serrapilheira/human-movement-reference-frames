analyze_elements_MED <- function(t, r, v, segments){

  # Description ----------------------------------------------------------------
  #
  # This function calculates 5 indices originated by applying the movement
  # element decomposition method to the movement data of one axis (x, y or z)
  # The method was developed by Miranda et al. (2018)
  #
  # Inputs:
  #   t = vector with the time of each frame of the data (double vector)
  #   r = time series of the position on one axis (double vector)
  #   v = time series of the velocity (double vector)
  #   segments = a list with two vectors containing the indices where the
  #   beginning and end of each element occurs (list vector)
  #
  # Outputs:
  #   D = Displacement of the element
  #   V = Average velocity of the element
  #   Dur = Duration of the element
  #   W = Similarity index of the element to the theoretical curve
  #   R2 = Calculated coefficient of determination between the element and
  #        the theoretical curve
  #
  # References:
  #   MIRANDA, J.G.V. et al. Complex upper-limb movements are generated by
  #   combining motor primitives that scale with the movement size.
  #   Scientific reports, v. 8, n. 1, p. 1-11, 2018.
  #   ⟨https://doi.org/10.1038/s41598-018-29470-y⟩
  #
  # Author: Mateus Souza Silva
  # Date: 20/08/2022
  # ----------------------------------------------------------------------------


  N <- length(segments$seg_i)                                                   # Creating vectors for output
  D <- c()
  V <- c()
  Dur <- c()
  W <- c()
  R2 <- c()

  if(N == 0){                                                                   # If there are no movement elements in this time series, return with empty vectors
    return(data.frame(D, V, Dur, W, R2))
  }

  for(i in seq(1,N)){                                                           # Loop for each movement element
    D <- append(D, r[segments$seg_f[i]] - r[segments$seg_i[i]])                 # Calculating the indices
    V <- append(V, mean(v[segments$seg_i[i] : segments$seg_f[i]]))
    Dur <- append(Dur, t[segments$seg_f[i]] - t[segments$seg_i[i]])

    fit <- fit_MED(t = t[segments$seg_i[i] : segments$seg_f[i]],                # Applying the fit_MED function to obtain the indices that relate the element to the theoretical curve
                   v = v[segments$seg_i[i] : segments$seg_f[i]])

    W <- append(W, as.numeric(fit[1]))
    R2 <- append(R2, as.numeric(fit[2]))
  }

  return(data.frame(D, V, Dur, W, R2))
}
